[ { "title": "Mybatis的一对一映射", "url": "/posts/mybatis%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84/", "categories": "Mybatis", "tags": "Mybatis", "date": "2021-12-27 20:34:08 +0800", "snippet": "一、自动别名映射 例如： r.role_name as &#39;role.role_name&#39;，会在类中查找role属性，如果这个属性存在就创建这个对象，然后在这个对象中查找roleName，将r.role_name绑定到role对象的roleName属性中&amp;lt;select id=&quot;selectUserAndRoleById&quot; resultType=&quot;cn.eaay.simple.dto.UserDto&quot;&amp;gt; select u.id, u.user_name userName, u.user_password userPassword, u.user_email userEmail, u.user_info userInfo, u.head_img headImg, u.create_time createTime, r.id &#39;role.id&#39;, r.role_name &#39;role.roleName&#39;, r.enabled &#39;role.enabled&#39;, r.create_by &#39;role.createBy&#39;, r.create_time &#39;role.createTime&#39; from sys_user u inner join sys_user_role ur on u.id = ur.user_id inner join sys_role r on ur.role_id = r.id where u.id = #{userId}&amp;lt;/select&amp;gt;结论：通过自动别名映射可以完成一对一映射，要注意对象中role属性的运用，别名中要用’role.属性’，要加引号。二、resultMap映射1、使用别名配置一对一映射 在 resultMap标签中result的property 属性中使用 role. 前缀。在column中为了避免不同表中存在相同的列，在可能重名的列中添加前缀 role_。使用这种方式时还需要在sql中设置别名。&amp;lt;resultMap id=&quot;userRoleMap&quot; type=&quot;cn.eaay.simple.dto.UserDto&quot; extends=&quot;userMap&quot;&amp;gt; &amp;lt;!-- role相关属性 --&amp;gt; &amp;lt;result column=&quot;role_id&quot; property=&quot;role.id&quot;/&amp;gt; &amp;lt;result column=&quot;role_name&quot; property=&quot;role.roleName&quot;/&amp;gt; &amp;lt;result column=&quot;enabled&quot; property=&quot;role.enabled&quot;/&amp;gt; &amp;lt;result column=&quot;create_by&quot; property=&quot;role.createBy&quot;/&amp;gt; &amp;lt;result column=&quot;role_create_time&quot; property=&quot;role.createTime&quot; jdbcType=&quot;TIMESTAMP&quot;/&amp;gt;&amp;lt;/resultMap&amp;gt; &amp;lt;!-- sql中的别名要与column相同 --&amp;gt;&amp;lt;select id=&quot;selectUserAndRoleById2&quot; resultMap=&quot;userRoleMap&quot;&amp;gt; select u.id, u.user_name, u.user_password, u.user_email, u.user_info, u.head_img, u.create_time, r.id role_id, r.role_name, r.enabled enabled, r.create_by create_by, r.create_time role_create_time from sys_user u inner join sys_user_role ur on u.id = ur.user_id inner join sys_role r on ur.role_id = r.id where u.id = #{userId}&amp;lt;/select&amp;gt;结论：这种方式需要在role的proerty中使用 “role.” 前缀，在column中为了避免不同表中存在相同名称的列，增加了 “role_” 前缀，并且还在在sql语句中配置 “role_” 前缀，十分繁琐。2、使用association标签配置一对一映射&amp;lt;resultMap id=&quot;roleMap&quot; type=&quot;cn.eaay.simple.model.SysRole&quot;&amp;gt; &amp;lt;id column=&quot;id&quot; property=&quot;id&quot;/&amp;gt; &amp;lt;result column=&quot;role_name&quot; property=&quot;roleName&quot;/&amp;gt; &amp;lt;result column=&quot;enabled&quot; property=&quot;enabled&quot;/&amp;gt; &amp;lt;result column=&quot;create_by&quot; property=&quot;createBy&quot;/&amp;gt; &amp;lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot;/&amp;gt;&amp;lt;/resultMap&amp;gt; &amp;lt;!-- association可以引用ResultMap--&amp;gt;&amp;lt;!-- columnPrefix配置别名前缀，在别名中使用，防止名称重复，注意 r.role_name也要加上前缀role_role_name --&amp;gt;&amp;lt;resultMap id=&quot;userRoleMapByAssociation2&quot; type=&quot;cn.eaay.simple.dto.UserDto&quot; extends=&quot;userMap&quot;&amp;gt; &amp;lt;association property=&quot;role&quot; columnPrefix=&quot;role_&quot; resultMap=&quot;cn.eaay.simple.mapper.SysRoleMapper.roleMap&quot;/&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!-- 使用ResultMap的association标签配置一对一映射 --&amp;gt;&amp;lt;select id=&quot;selectUserAndRoleById3&quot; resultMap=&quot;userRoleMapByAssociation2&quot;&amp;gt; select u.id, u.user_name, u.user_password, u.user_email, u.user_info, u.head_img, u.create_time, r.id role_id, r.role_name role_role_name, r.enabled role_enabled, r.create_by role_create_by, r.create_time role_create_time from sys_user u inner join sys_user_role ur on u.id = ur.user_id inner join sys_role r on ur.role_id = r.id where u.id = #{userId}&amp;lt;/select&amp;gt;结论：在resultMap中不仅可以使用继承的方式，association中也可以使用resultMap属性引用其它的resultMap，一目了然，简化并重用了代码三、嵌套查询及延迟加载 将主查询中列的结果作为嵌套查询的参数。嵌套查询会执行两次sql查询，第一次将主查询结果查询出来，注意主查询中存在一个roleId列，这是一个别名，也可以是数据库的字段role_id，与column的值对应。将association的column设置为roleId会将此作为参数来查询。触发某些方法时进行延迟加载，lazyLoadTriggerMethods=”equals,clone,hashCode,toString”&amp;lt;!-- 在mybatis配置文件，配置此选项 --&amp;gt;&amp;lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&amp;gt;&amp;lt;!-- association标签的嵌套查询 --&amp;gt;&amp;lt;resultMap id=&quot;userRoleMapSelect&quot; type=&quot;cn.eaay.simple.dto.UserDto&quot; extends=&quot;userMap&quot;&amp;gt; &amp;lt;association property=&quot;role&quot; column=&quot;roleId&quot; select=&quot;cn.eaay.simple.mapper.SysRoleMapper.selectRoleById&quot;/&amp;gt;&amp;lt;/resultMap&amp;gt;&amp;lt;!-- 嵌套查询 --&amp;gt;&amp;lt;select id=&quot;selectUserAndRoleByIdSelect&quot; resultMap=&quot;userRoleMapSelect&quot;&amp;gt; select u.id, u.user_name, u.user_password, u.user_email, u.user_info, u.head_img, u.create_time, ur.role_id roleId from sys_user u inner join sys_user_role ur on u.id = ur.user_id where u.id = #{userId}&amp;lt;/select&amp;gt;结论：在嵌套查询时要注意column属性的值是次查询的参数，要指定为主查询的列。通过指定延迟加载完成按需加载。" }, { "title": "欢迎光临!", "url": "/posts/welcome-to-jekyll/", "categories": "Spring, SpringBoot", "tags": "詹姆斯, 科比", "date": "2021-12-15 18:42:08 +0800", "snippet": "这是我的第一个博客，欢迎您来到这里 public static void main(String[] args) { System.out.println(&quot;Hello World&quot;); }echo &#39;No more line numbers!&#39;public static void main(String[] args) { System.out.println(&quot;Hello World&quot;);}" }, { "title": "Spring最佳实践!", "url": "/posts/sprin-demo/", "categories": "Spring", "tags": "SpringCloud", "date": "2021-12-15 18:42:08 +0800", "snippet": "Spring依赖注入、面向切面编程 public static void main(String[] args) { System.out.println(&quot;Hello World&quot;); }echo &#39;No more line numbers!&#39;public static void main(String[] args) { System.out.println(&quot;Hello World&quot;);}" } ]
